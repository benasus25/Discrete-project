<!DOCTYPE html>
<html lang ="en">
    <head>
        <meta charset="utf-8">
        <title>Algo-point</title>
        <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/4.5.2/css/bootstrap.min.css">
        <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.16.0/umd/popper.min.js"></script>
        <script src="https://maxcdn.bootstrapcdn.com/bootstrap/4.5.2/js/bootstrap.min.js"></script>
    </head>
    <body>
        <div class="jumbotron jumbotron-fluid">
        <div class="container-fluid bg-grey text-black">
          <h1 style="text-align: center; color: brown;"><a href = "home" style="color: brown;">Algo-point</a></h1>
        </div>
        </div>
        <div class="row">
            <div class="col-sm-2" style="background-color:lavender;"><h2 style="text-align: center;">Glossary</h2>
                <ul class="nav flex-column">
                    <li class ="nav-item"><h6>&ensp;Time Complexity</h6></li>
                    <ul>
                        <li class = "nav-item"><a href ="aanalysis"> Asymptotic Analysis </a></li>
                        <li class = "nav-item"><a href="thetano">Theta Notation</a></li>
                        <li class = "nav-item"><a href= "bigono">Big-O Notation</a></li>
                        <li class = "nav-item"><a href="omegano">Omega Notation</a></li>
                    </ul>
                    <li class ="nav-item"><h6>&ensp;Searching Algorithms</h6></li>
                    <ul>
                        <li class="nav-item"><a href="linearsearch">Linear Search</a></li>
                        <li class="nav-item"><a href = "binarysearch">Binary Search</a></li>
                    </ul>
                    <li class ="nav-item"><h6>&ensp; Sorting Algorithms</h6></li>
                    <ul>
                        <li class="nav-item"><a href ="selectionsort">Selection Sort</a></li>
                        <li class="nav-item"><a href = "bubblesort">Bubble Sort</a></li>
                        <li class="nav-item"><a href = "insertionsort">Insertion Sort</a></li>
                        <li class="nav-item"><a href = "countingsort">Counting Sort</a></li>
                    </ul>
                    <li class ="nav-item"><h6>&ensp;Graph Algorithms</h6></li>
                    <ul>
                        <li class="nav-item"><a href = "bfs">Breadth First Search(BFS)</a></li>
                        <li class="nav-item"><a href = "dfs">Depth First Search(DFS)</a></li>
                        <li class="nav-item"><a href = "prim">Prim Algorithm</a></li>
                        <li class="nav-item"><a href = "kruskal">Kruskal Algorithm</a></li>
                        <li class="nav-item"><a href = "warshall">Dijkstra Alorithm</a></li>
                    </ul>
                    <li class ="nav-item"><h6>&ensp;Tree Operations</h6></li>
                    <ul>
                        <li class="nav-item"><a href = "inordertree">Inorder</a></li>
                        <li class="nav-item"><a href = "searchtree">Search</a></li>
                        <li class="nav-item"><a href = "inserttree">Insert</a></li>
                        <li class="nav-item"><a href = "deletetree">Delete</a></li>
                    </ul>
                    <li class="nav-item"><h6>&ensp;Applications of Algorithms</h6></li>
                    <ul>
                        <li class="nav-item"><a href="table">Truth Table Generator</a></li>
                    </ul>
                </ul>  
            </div>
            <div class="col-sm-10" style="background-color:lavenderblush;"><h2 style="text-align: center;">Theory</h2>
                <p style="font-size: large; color: black; text-align: left;">
                    Breadth-first search (BFS) is an algorithm for traversing or searching tree or graph data structures. It starts at the tree root (or some arbitrary node of a graph, sometimes referred to as a 'search key'), and explores all of the neighbor nodes at the present depth prior to moving on to the nodes at the next depth level.<br>
                    <br>Pseudo-Code<br>
                    BFS(G,s){where G is the graph in which the search occurs and s is the element to be searched}<br>
                    <ol>
                        <li>
                            For each vertex u ⊆ G.v - {s}<br>
                            u.color= white<br>
                            u.d=INF<br>
                            u.π = NIL<br> 
                        </li>
                        <li>s.color = gray<br>
                        s.d=0<br>
                        s.π = NIL
                    </li>
                    <li>
                        Q = ∅
                    </li>
                    <li>Enqueue(Q, s)</li>
                    <li>While Q != ∅<br>
                        u = Dequeue(Q)<br>
                        For each v ⊆ G.adj[u]<br>
                        If v.color == white<br>
                        &ensp;v.color = gray<br>
                        &ensp;v.d = u.d + 1<br>
                        &ensp;v.π = u<br>
                        &ensp;Enqueue(Q, v)<br>
                        u.color=black
                    </li>
                    </ol>
                </p>
                <p style="font-size: large; color: black; text-align: left;">
                    Time complexity: O(V + E), where V is number of vertices and E is number of edges.<br>
                    Proof of Time Complexity<br>
                    After initialization, breadth-first search never whitens a vertex, and thus the test in line 13 ensures that each vertex is enqueued at most once, and hence dequeued at most once. The operations of enqueuing and dequeuing take O(1)time, and so the total time devoted to queue operations is O(V). Because the procedure scans the adjacency list of each vertex only when the vertex is dequeued, it scans each adjacency list at most once. Since the sum of the lengths of all the adjacency lists is O(E), the total time spent in scanning adjacency lists is O(E). The overhead for initialization is O(V), and thus the total running time of the BFS procedure is O(V + E).
                </p>
            </div>  
          </div>
        </body>
</html>